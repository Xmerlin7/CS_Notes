# Explanation
- The generic technique we will use is something that is referred to as **hardware-based address translation**.
- With address translation, the hardware transforms each memory access, changing the **virtual** address provided by the instruction to a **physical** address where the desired information is actually located.
- The hardware alone cannot virtualize memory, as it just provides the low-level mechanism for doing so efficiently. The OS must get involved at key points to set up the hardware so that the correct translations take place: 
	- It must **manage memory** by keeping track of which locations are free and which are in use.
	- Judiciously intervening to maintain control over how memory is used.
##### Assumptions
- We will assume for now that:
	1. The user’s address space must be placed contiguously in physical memory. 
	2. The size of the address space is not too big; specifically, that it is less than the size of physical memory.
	3. Each address space is exactly the same size.
##### An Example
- From the program’s perspective, its **address space** starts at address 0 and grows to a maximum of 16 KB; all memory references it generates should be within these bounds.
- However, to virtualize memory, the OS wants to place the [[Process]] somewhere else in physical memory, not necessarily at address 0.
    ![[A Process And Its Address Space.png|300]] ![[Physical Memory with a Single Relocated Process.png|320]]
##### Dynamic Relocation (base and bounds)
- Two hardware registers are needed within each CPU: 
	- one is called the **base register**
	- The other is called **the bounds** (sometimes called a **limit register**).
- In this setup, each program is written and compiled as if it is loaded at address zero. 
- However, when a program starts running, the OS decides where in physical memory it should be loaded and sets the base register to that value.
- when any memory reference is generated by the process, it is translated by the processor in the following manner: _physical address = virtual address + base_
- Each memory reference generated by the process is a **virtual address**. 
- The hardware in turn adds the contents of the base register to this address and the result is a **physical address** that can be issued to the memory system.
- The bounds register is there to help with **protection**.
	- The processor will first check that the memory reference is within bounds to make sure it is legal.
- If a process generates a virtual address that is greater than (or equal to) the bounds, or one that is negative, the CPU will raise an exception, and the process will likely be terminated.
- Sometimes people call the part of the processor that helps with address translation the **memory management unit (MMU)**.
- Bound registers can be defined in one of two ways: 
	- In one way, it holds the size of the address space, and thus the hardware checks the virtual address against it first before adding the base. 
	- In the second way, it holds the physical address of the end of the address space, and thus the hardware first adds the base and then makes sure the address is within bounds.
##### Operating System Issues
- When a new process is created, the OS will have to search a data structure (often called a **free list**) to find room for the new address space and then mark it used.
- The OS must _save and restore_ the base-and-bounds pair when it switches between processes. 
- When the OS decides to stop running a process, it must save the values of the base and bounds registers to memory, in some per-process structure such as the **process structure** or **process control block (PCB)**.
- when a process is stopped (i.e., not running), it is possible for the OS to move an address space from one location in memory to another rather easily. 
- To move a process’s address space, the OS first deschedules the process; then, the OS copies the address space from the current location to the new location; finally, the OS updates the saved base register (in the process structure) to point to the new location.
# Sources
- Operating Systems: Three Easy Pieces - Chapter 15.
- [Lecture 3 - part 2](https://youtu.be/I0RIlSN0DzM)